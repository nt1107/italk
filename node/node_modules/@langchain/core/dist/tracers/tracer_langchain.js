import { Client } from "langsmith";
import { getCurrentRunTree } from "langsmith/singletons/traceable";
import { getEnvironmentVariable, getRuntimeEnvironment } from "../utils/env.js";
import { BaseTracer } from "./base.js";
export class LangChainTracer extends BaseTracer {
    constructor(fields = {}) {
        super(fields);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "langchain_tracer"
        });
        Object.defineProperty(this, "projectName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "exampleId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const { exampleId, projectName, client } = fields;
        this.projectName =
            projectName ??
                getEnvironmentVariable("LANGCHAIN_PROJECT") ??
                getEnvironmentVariable("LANGCHAIN_SESSION");
        this.exampleId = exampleId;
        this.client = client ?? new Client({});
        // if we're inside traceable, we can obtain the traceable tree
        // and populate the run map, which is used to correctly
        // infer dotted order and execution order
        const traceableTree = this.getTraceableRunTree();
        if (traceableTree) {
            let rootRun = traceableTree;
            const visited = new Set();
            while (rootRun.parent_run) {
                if (visited.has(rootRun.id))
                    break;
                visited.add(rootRun.id);
                if (!rootRun.parent_run)
                    break;
                rootRun = rootRun.parent_run;
            }
            visited.clear();
            const queue = [rootRun];
            while (queue.length > 0) {
                const current = queue.shift();
                if (!current || visited.has(current.id))
                    continue;
                visited.add(current.id);
                // @ts-expect-error Types of property 'events' are incompatible.
                this.runMap.set(current.id, current);
                if (current.child_runs) {
                    queue.push(...current.child_runs);
                }
            }
            this.client = traceableTree.client ?? this.client;
            this.projectName = traceableTree.project_name ?? this.projectName;
            this.exampleId = traceableTree.reference_example_id ?? this.exampleId;
        }
    }
    async _convertToCreate(run, example_id = undefined) {
        return {
            ...run,
            extra: {
                ...run.extra,
                runtime: await getRuntimeEnvironment(),
            },
            child_runs: undefined,
            session_name: this.projectName,
            reference_example_id: run.parent_run_id ? undefined : example_id,
        };
    }
    async persistRun(_run) { }
    async onRunCreate(run) {
        const persistedRun = await this._convertToCreate(run, this.exampleId);
        await this.client.createRun(persistedRun);
    }
    async onRunUpdate(run) {
        const runUpdate = {
            end_time: run.end_time,
            error: run.error,
            outputs: run.outputs,
            events: run.events,
            inputs: run.inputs,
            trace_id: run.trace_id,
            dotted_order: run.dotted_order,
            parent_run_id: run.parent_run_id,
        };
        await this.client.updateRun(run.id, runUpdate);
    }
    getRun(id) {
        return this.runMap.get(id);
    }
    getTraceableRunTree() {
        try {
            return getCurrentRunTree();
        }
        catch {
            return undefined;
        }
    }
}
